# Chapter04 연산자
***

## 1. 산술 연산자
### 예제 : Ch04_Ex01_Arithmetic

| 연산자 | 설명       | 사용 예  | 결과 |
|:----|:---------|-------|----|
| +   | 더하기      | 5 + 2 | 7  |
| -   | 빼기       | 5 - 2 | 3  |
| *   | 곱하기      | 5 * 2 | 10 |
| /   | 나누기의 몫   | 5 / 2 | 2  |
| %   | 나누기의 나머지 | 5 % 2 | 1  |

<br><br>

## 2. 대입 연산자와 복합 대입 연산자
### 예제 : Ch04_Ex02_Assignment
> - 대입 연산자 (=) : 오른쪽에 있는 연산식의 결과를 왼쪽에 있는 변수로 저장
> 
> - 복합 대입 연산자 : 연산과 할당(=)을 합쳐놓은 것
>   - 코드가 간결해진다.
>   - 형변환 없이 연산이 수행된다(자동 형변환).

| 연산자    | 설명 (다른 방법) |
|:-------|:-----------|
| a += b | a = a + b  |
| a -= b | a = a - b  |
| a *= b | a = a * b  |
| a /= b | a = a / b  |
| a %= b | a = a % b  |

<br><br>

## 3. 부호 연산자와 증감 연산자
### 예제: Ch04_Ex03_PlusMinusSign
### 예제: Ch04_Ex04_PrefixPostfix

> - 부호 연산자: 기본 자료형의 숫자 부호
> - 증감 연산자: 변수의 값을 1 증가 시키거나 1 감소시킴

| 연산자 | 사용 예 | 설명                        |
|:----|:----|---------------------------|
| +   | +x  | 부호 유지(의미없는 연산)            |
| -   | -x  | 부호 반전                     |
| ++  | ++x | 다른 연산 전 x값을 증가시킴 (전위 연산자) |
|     | x++ | 다른 연산 후 x값을 증가시킴 (후위 연산자) |
| --  | --x | 다른 연산 전 x값을 감소시킴          |
|     | x-- | 다른 연산 후 x값을 감소시킴          |

<br><br>

## 4. 비교 연산자(관계 연산자)
> 비교 연산자: 두 피연산자를 비교해 결괏값으로 논리 값인 true와 false를 반환한다.

```
int x = 2; 
int y = 1;
```


| 연산자 | 사용 예   | 설명             | 결과    |
|:----|:-------|----------------|-------|
| ==  | x == y | x와 y는 같다.      | false |
| !=  | x != y | x와 y는 같지 않다.   | true  |
| `>` | x > y  | x는 y보다 크다.     | true  |
| `>=`  | x >= y | x는 y보다 크거나 같다. | true  |
| <   | x < y  | x는 y보다 작다.     | false |
| <=  | x <= y | x는 y보다 작거나 같다. | false |

```
if( x > y ) {

}
```
> 위의 예를 보면 if문이 연산 결과를 만드는 것이 아닌 if문은 true, false만 확인하고 비교 연산자가 true, false를 만든다.
>> 'x가 y보다 크면'이 아닌 if(true)라고 생각하자.
```
if( true ) {

}
```

### 예제: Ch04_Ex05_Compare
```
1.0 == 1 : true
1.0 != 1 : false
```
> 1.0과 1은 실수와 정수인데, 실수형으로 자동 형변환이 이뤄진 다음 비교 연산을 수행한다.

<br><br>

## 5. 논리 연산자
### 예제: Ch04_Ex06_Logical
> - 두 명제가 모두 참이면 논리곱은 참이다.
> - 두 명제 중 하나라도 참이면 논리합은 참이다.
> - 참의 부정은 거짓, 거짓의 부정은 참이다.

| 연산자                 | 기능                                       |
|---------------------|------------------------------------------|
| && <br> (논리곱, And)  | 두 항이 모두 참이면 결괏값은 참이다. <br> 그렇지 않은 경우 거짓이다. |
| \|\| <br> (논리합, Or) | 두 항 중 하나의 항이라도 참이면 결괏값은 참이다. <br> 두 항 모두 거짓이면 결괏값은 거짓이다. |
| ! <br> (부정, Not)    | 값이 참인 경우는 거짓으로 바뀐다. <br> 값이 거짓인 경우는 참으로 바뀐다. |

| A | B     | A && B | A \|\| B | !A    |
|-|-------|-|-|-------|
| true | true  | true | true | false |
| true | false | false | true | false |
| false | true  | false | true | true  |
| false | false  | false | false | true  |

<br>

### 5.1 논리 연산자 주의점
> SCE(Short-Circuit-Evaluation)
>> 연산의 효율 및 속도의 향상을 위해 불필요한 연산을 수행하지 않는 기능

#### 예제: Ch04_Ex07_ShortCircuitEvaluation
```
int x = 1;
int y = 0;
result = ((x = x + 1) > 0) || ((y = y+ 1) > 0);
```
결과
```
result = true
x = 2
y = 0
```
> - 앞의 논리값이 true일 때, 뒤의 결과와 상관없이 true이므로 뒤쪽에 있는 y 연산이 수행되지 않는다.
> -  마찬가지로 &&일 때는 앞의 논리값이 false일 때, 뒤의 결과와 상관없이 false이므로 뒤쪽 연산이 수행되지 않는다.

<br><br>

## 6. 조건 연산자
> 조건식이 참인 경우와 거짓인 경우에 다른 결괏값을 나타내주는 연산자
>> 조건식 ? 참일 때 실행 : 거짓일 때 실행;

### 예제: Ch04_Ex08_Condition
```
int big = (num1 > num2) ? num1 : num2;
```
> num1이 num2보다 클 경우 참이므로 num1 부분이 실행되고, <br> num1이 num2보다 작을 경우 거짓이므로 num2 부분이 실행된다.

<br><br>

## 7. 단항·이항·삼항 연산자
> - 단항 연산자: ++x, --y에서 ++, --처럼 하나의 피연산자만으로 이루어진 식으로 연산을 수행
> - 이항 연산자: x + y 에서 + 연산자처럼 피연산자 두개를 가지고 식을 구성
> - 삼항 연산자: 항이 세 개 있는 연산자
>   - 1항 ? 2항 : 3항 ;

<br><br>

## 8. 연산자 우선 순위
| 우선순위 | 종류 | 연산자                                                                          |
|-----|----|------------------------------------------------------------------------------|
| 1   |    | .<sup>점</sup> [ ]<sup>대괄호</sup> ( )<sup>소괄호</sup>                            |
| 2   | 단항 | ++<sup>증가</sup> --<sup>감소</sup> !<sup>부정</sup> +<sup>부호</sup> -<sup>부호</sup> |
| 3   | 산술 | *<sup>곱하기</sup> /<sup>나누기 몫</sup> %<sup>나머지</sup>                            |
| 4   | 산술 | +<sup>더하기</sup> -<sup>빼기</sup>                                               |
| 5   | 비교 | <<sup>작다</sup> <=<sup>작거나 같다</sup> ><sup>크다</sup> >=<sup>크거나 같다</sup>        |
| 6   | 관계 | ==<sup>같다</sup> !=<sup>같지 않다</sup> |
| 7   | 논리곱 | &&<sup>and</sup> |
| 8   | 논리합 | \|\|<sup>or</sup> |
| 9   | 조건 | booleanExpression ? exp1 : exp2 |
| 10  | 대입 | = += -= *= /= %= |

### 예제: Ch04_Ex09_Order
코드1
```
int num = 5;
System.out.println(num + '\n');
```
결과
```
15
```
> - 'n' : 문자형
> - "n" : 스트링 객체, 글자들

> 1. num 변수에는 값이 이미 이진수로 들어가 있다.
> 2. '\n'은 문자형 데이터이기 때문에 2바이트 크기를 가질 것이고, 이진수로 변환, 즉 인코딩이 된다.
> 3. 크기가 다르니 뒤쪽 값이 2바이트에서 4바이트로 형변환이 된다.
> 4. 5(정수) + 10(유니코드에서 '\n'의 값)으로 계산되어 15가 된다.

<br>

코드2
```
int num = 5;
System.out.println(num + "\n");
```
결과
```
5

```
> - 산술 연산은 데이터가 기본 자료형일 때만 일어난다.
> - '기본 자료형 + 스트링' 연산이 일어나지 않는다.

> 1. 5 + "\n" <br> 산술 연산이 안되니 5를 글자 "5"로 바꾼다.
> 2. "5\n" <br> 두개가 합쳐진다.

<br>

코드3
```
System.out.println("3 >= 2 : " + 3 >= 2);
```
결과
```
The Operator >= is undefined for the argument type(s) String, int
```

> 1. "3 >= 2 : " + 3 >= 2 <br> 연산자의 우선순위에 의해 +가 먼저 연산돼서 두 문자열이 합쳐진다.
> 2. "3 >= 2 : 3" >= 2 <br> 글자와 숫자라 비교할 수 없어서 컴파일 에러가 난다.

